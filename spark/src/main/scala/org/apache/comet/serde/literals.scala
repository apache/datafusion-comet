/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.comet.serde.literals

import org.apache.spark.internal.Logging
import org.apache.spark.sql.catalyst.expressions.{Attribute, Literal}
import org.apache.spark.sql.catalyst.util.GenericArrayData
import org.apache.spark.sql.types.{ArrayType, BinaryType, BooleanType, ByteType, DateType, Decimal, DecimalType, DoubleType, FloatType, IntegerType, LongType, NullType, ShortType, StringType, TimestampNTZType, TimestampType}
import org.apache.spark.unsafe.types.UTF8String

import com.google.protobuf.ByteString

import org.apache.comet.CometConf
import org.apache.comet.CometSparkSessionExtensions.withInfo
import org.apache.comet.DataTypeSupport.isComplexType
import org.apache.comet.serde.{CometExpressionSerde, Compatible, ExprOuterClass, LiteralOuterClass, SupportLevel, Unsupported}
import org.apache.comet.serde.QueryPlanSerde.{serializeDataType, supportedDataType}
import org.apache.comet.serde.Types.ListLiteral

object CometLiteral extends CometExpressionSerde[Literal] with Logging {

  override def getSupportLevel(expr: Literal): SupportLevel = {

    if (supportedDataType(
        expr.dataType,
        allowComplex = expr.value == null ||
          // Nested literal support for native reader
          // can be tracked https://github.com/apache/datafusion-comet/issues/1937
          // now supports only Array of primitive
          (Seq(CometConf.SCAN_NATIVE_ICEBERG_COMPAT, CometConf.SCAN_NATIVE_DATAFUSION)
            .contains(CometConf.COMET_NATIVE_SCAN_IMPL.get()) && expr.dataType
            .isInstanceOf[ArrayType]) && !isComplexType(
            expr.dataType.asInstanceOf[ArrayType].elementType))) {
      Compatible(None)
    } else {
      Unsupported(Some(s"Unsupported data type ${expr.dataType}"))
    }
  }

  override def convert(
      expr: Literal,
      inputs: Seq[Attribute],
      binding: Boolean): Option[ExprOuterClass.Expr] = {
    val dataType = expr.dataType
    val value = expr.value

    val exprBuilder = LiteralOuterClass.Literal.newBuilder()

    if (value == null) {
      exprBuilder.setIsNull(true)
    } else {
      exprBuilder.setIsNull(false)
      dataType match {
        case _: BooleanType => exprBuilder.setBoolVal(value.asInstanceOf[Boolean])
        case _: ByteType => exprBuilder.setByteVal(value.asInstanceOf[Byte])
        case _: ShortType => exprBuilder.setShortVal(value.asInstanceOf[Short])
        case _: IntegerType | _: DateType => exprBuilder.setIntVal(value.asInstanceOf[Int])
        case _: LongType | _: TimestampType | _: TimestampNTZType =>
          exprBuilder.setLongVal(value.asInstanceOf[Long])
        case _: FloatType => exprBuilder.setFloatVal(value.asInstanceOf[Float])
        case _: DoubleType => exprBuilder.setDoubleVal(value.asInstanceOf[Double])
        case _: StringType =>
          exprBuilder.setStringVal(value.asInstanceOf[UTF8String].toString)
        case _: DecimalType =>
          // Pass decimal literal as bytes.
          val unscaled = value.asInstanceOf[Decimal].toBigDecimal.underlying.unscaledValue
          exprBuilder.setDecimalVal(com.google.protobuf.ByteString.copyFrom(unscaled.toByteArray))
        case _: BinaryType =>
          val byteStr =
            com.google.protobuf.ByteString.copyFrom(value.asInstanceOf[Array[Byte]])
          exprBuilder.setBytesVal(byteStr)
        case a: ArrayType =>
          val listLiteralBuilder = ListLiteral.newBuilder()
          val array = value.asInstanceOf[GenericArrayData].array
          a.elementType match {
            case NullType =>
              array.foreach(_ => listLiteralBuilder.addNullMask(true))
            case BooleanType =>
              array.foreach(v => {
                val casted = v.asInstanceOf[java.lang.Boolean]
                listLiteralBuilder.addBooleanValues(casted)
                listLiteralBuilder.addNullMask(casted != null)
              })
            case ByteType =>
              array.foreach(v => {
                val casted = v.asInstanceOf[java.lang.Integer]
                listLiteralBuilder.addByteValues(casted)
                listLiteralBuilder.addNullMask(casted != null)
              })
            case ShortType =>
              array.foreach(v => {
                val casted = v.asInstanceOf[java.lang.Short]
                listLiteralBuilder.addShortValues(
                  if (casted != null) casted.intValue()
                  else null.asInstanceOf[java.lang.Integer])
                listLiteralBuilder.addNullMask(casted != null)
              })
            case IntegerType | DateType =>
              array.foreach(v => {
                val casted = v.asInstanceOf[java.lang.Integer]
                listLiteralBuilder.addIntValues(casted)
                listLiteralBuilder.addNullMask(casted != null)
              })
            case LongType | TimestampType | TimestampNTZType =>
              array.foreach(v => {
                val casted = v.asInstanceOf[java.lang.Long]
                listLiteralBuilder.addLongValues(casted)
                listLiteralBuilder.addNullMask(casted != null)
              })
            case FloatType =>
              array.foreach(v => {
                val casted = v.asInstanceOf[java.lang.Float]
                listLiteralBuilder.addFloatValues(casted)
                listLiteralBuilder.addNullMask(casted != null)
              })
            case DoubleType =>
              array.foreach(v => {
                val casted = v.asInstanceOf[java.lang.Double]
                listLiteralBuilder.addDoubleValues(casted)
                listLiteralBuilder.addNullMask(casted != null)
              })
            case StringType =>
              array.foreach(v => {
                val casted = v.asInstanceOf[org.apache.spark.unsafe.types.UTF8String]
                listLiteralBuilder.addStringValues(if (casted != null) casted.toString else "")
                listLiteralBuilder.addNullMask(casted != null)
              })
            case _: DecimalType =>
              array
                .foreach(v => {
                  val casted =
                    v.asInstanceOf[Decimal]
                  listLiteralBuilder.addDecimalValues(if (casted != null) {
                    com.google.protobuf.ByteString
                      .copyFrom(casted.toBigDecimal.underlying.unscaledValue.toByteArray)
                  } else ByteString.EMPTY)
                  listLiteralBuilder.addNullMask(casted != null)
                })
            case _: BinaryType =>
              array
                .foreach(v => {
                  val casted =
                    v.asInstanceOf[Array[Byte]]
                  listLiteralBuilder.addBytesValues(if (casted != null) {
                    com.google.protobuf.ByteString.copyFrom(casted)
                  } else ByteString.EMPTY)
                  listLiteralBuilder.addNullMask(casted != null)
                })
          }
          exprBuilder.setListVal(listLiteralBuilder.build())
          exprBuilder.setDatatype(serializeDataType(dataType).get)
        case dt =>
          withInfo(s"Unexpected datatype '$dt' for literal value '$value'")
          return None
      }
    }

    val dt = serializeDataType(dataType)

    if (dt.isDefined) {
      exprBuilder.setDatatype(dt.get)

      Some(
        ExprOuterClass.Expr
          .newBuilder()
          .setLiteral(exprBuilder)
          .build())
    } else {
      withInfo(expr, s"Unsupported datatype $dataType")
      None
    }

  }
}
